{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9afb17b3",
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "from torchvision import transforms\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "import os, random\n",
    "import numpy as np\n",
    "import torchvision \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "data_folder = \"/Users/dell/Desktop/assignments/Task4VAD/com4511/audio\"\n",
    "labs_folder = \"/Users/dell/Desktop/assignments/Task4VAD/com4511/labels\"\n",
    "\n",
    "training_prefixes = [\"N\", \"V\"]\n",
    "validation_prefixes = [\"E\"]\n",
    "testing_prefixes = [\"C\"]\n",
    "\n",
    "\n",
    "class VoiceDataSet(Dataset):\n",
    "    def __init__(self, dataset, transform = None, window_length = 512):\n",
    "        self.prefix = [\"C\"]\n",
    "        if dataset.lower() == \"train\":\n",
    "            self.prefix = training_prefixes\n",
    "        if dataset.lower() == \"val\":\n",
    "            self.prefix = validation_prefixes\n",
    "        if dataset.lower() == \"test\":\n",
    "            print(dataset.lower())\n",
    "            self.prefix == [\"C\"]\n",
    "\n",
    "        self.paths = self.gen_paths(self.prefix)\n",
    "        self.len = len(self.paths[0])\n",
    "        self.win = window_length\n",
    "        self.transform = transform\n",
    "           \n",
    "           \n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        X, y = self.read_data_from_path(self.paths[0][idx], self.paths[1][idx])\n",
    "        l = X.size(dim = 0)\n",
    "        i = random.randint(0, l - self.win)\n",
    "         \n",
    "        if self.win == 0:\n",
    "            if self.transform:\n",
    "                temp = X.view(1, -1, 13).permute(2, 0, 1)\n",
    "            \n",
    "                X = self.transform(temp)\n",
    "                X = X.view(13, -1).permute(1, 0)\n",
    "                return X, y.type(torch.float32)\n",
    "            else:\n",
    "                return X, y.type(torch.float32)\n",
    "        \n",
    "        X = X[i:i+self.win]\n",
    "        y = y[i:i+self.win]\n",
    "        \n",
    "        \n",
    "        if self.transform:\n",
    "            temp = X.view(1, -1, 13).permute(2, 0, 1)\n",
    "            \n",
    "            X = self.transform(temp)\n",
    "            X = X.view(13, -1).permute(1, 0)\n",
    "           \n",
    "            \n",
    "        \n",
    "        return X, y.type(torch.float32) \n",
    "    \n",
    "    def __len__(self):\n",
    "        return self.len\n",
    "    \n",
    "\n",
    "    def read_data_from_path(self, d_path, l_path):\n",
    "\n",
    "        with open(d_path, 'rb') as f:\n",
    "            X = torch.from_numpy(np.load(f))\n",
    "        \n",
    "        with open(l_path, 'rb') as f:\n",
    "            y = torch.from_numpy(np.load(f))\n",
    "        \n",
    "        return X, y\n",
    "        \n",
    "    def gen_paths(self, prefixes):\n",
    "        \"\"\"gen_paths given a prefix, generate paths to files\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        prefixes : string\n",
    "            Prefix for train, dev or test\n",
    "\n",
    "        Returns\n",
    "        -------\n",
    "        (str, str)\n",
    "            (data path, labels path))\n",
    "        \"\"\"\n",
    "        os.chdir(data_folder)\n",
    "        data_paths = [f\"{data_folder}/{file}\" for file in os.listdir() if file[0] in prefixes]\n",
    "        \n",
    "        os.chdir(labs_folder)\n",
    "        labs_paths = [f\"{labs_folder}/{file}\" for file in os.listdir() if file[0] in prefixes]\n",
    "        \n",
    "        return (data_paths, labs_paths)\n",
    "    \n",
    "     \n",
    "    def calc_means_std(self, prefixes = None):\n",
    "        if not prefixes:\n",
    "            prefixes = self.prefix\n",
    "        a_paths, l_paths = self.gen_paths(self,prefixes=prefixes)\n",
    "        a_data, l_data = [], []\n",
    "        \n",
    "        for a, l in zip(a_paths, l_paths):\n",
    "            temp_d, temp_l = self.read_data_from_path(self, a, l)\n",
    "            a_data.append(temp_d)\n",
    "        \n",
    "        total_data = torch.cat(a_data)\n",
    "        \n",
    "        stds, means = torch.std_mean(total_data, dim=0)\n",
    "        \n",
    "        return stds, means"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
